/*
 * Sega Nomad Switchless Mod - Arduino Nano + OLED Version
 * Based on original Saturn Switchless Mod by Sebastian Kienzl <seb@riot.org>
 * Portiert für Arduino Nano mit 128x32 OLED Display
 * 
 * Hardware:
 * - Arduino Nano (ATmega328P)
 * - 128x32 OLED Display (SSD1306, I2C)
 * - Taster für Regionswechsel
 * 
 * Anschlüsse:
 * Button:     Pin 2 (mit internem Pull-up)
 * OLED SDA:   Pin A4 (I2C)
 * OLED SCL:   Pin A5 (I2C)
 * OLED VCC:   3.3V oder 5V
 * OLED GND:   GND
 * 
 * Region Outputs (Nomad Jumper):
 * JP1:        Pin 3 (Digital Out - JAP/English Region)
 * JP3:        Pin 4 (Digital Out - 50Hz/60Hz Video Format)
 * 
 * Video Format Output:
 * VF (50/60): Pin 6 (Digital Out - zusätzliche VF-Steuerung falls vorhanden)
 * 
 * Reset Output:
 * RST:        Pin 7 (Digital Out, Open-Drain)
 */

#include <Arduino.h>
#include <EEPROM.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

// OLED Display Konfiguration
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 32
#define OLED_RESET -1  // Reset pin nicht verwendet (shared reset)
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

// Sega Nomad Logo Bitmap (128x31 Pixel)
#define NOMAD_HEIGHT 31
#define NOMAD_WIDTH 128

// array size is 496
static const unsigned char nomad[] PROGMEM = {
  0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x03, 0xf0, 0x1e, 0x03, 0x00, 0x1e, 0x80, 0x03, 0xf8, 0x03, 0xf8, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x07, 0xf0, 0x3f, 0x8f, 0xf8, 0x3f, 0xc0, 0x07, 0xfc, 0x07, 0xf8, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x0f, 0xf0, 0x7f, 0x3f, 0xfc, 0x7f, 0xc0, 0x0f, 0xf8, 0x0f, 0xf8, 0x00, 0x26, 0x00, 
  0x00, 0x00, 0x1f, 0xe0, 0xff, 0xff, 0xfc, 0xff, 0xc0, 0x3f, 0xf8, 0x3f, 0xf8, 0x7f, 0xff, 0xfc, 
  0x00, 0x00, 0x3f, 0xe0, 0xfe, 0xfe, 0x3c, 0xff, 0x80, 0xff, 0xf0, 0x3f, 0xf3, 0xff, 0xff, 0xfc, 
  0x00, 0x00, 0x7f, 0xe1, 0xfd, 0xfc, 0x3d, 0xff, 0x81, 0xff, 0xc0, 0x7f, 0xf7, 0xff, 0xff, 0xfe, 
  0x00, 0x00, 0xff, 0xe3, 0xfb, 0xf8, 0x79, 0xff, 0x03, 0xff, 0xc1, 0xff, 0xf0, 0xff, 0xc0, 0xff, 
  0x00, 0x01, 0xff, 0xc7, 0xff, 0xf0, 0xff, 0xfe, 0x0f, 0xff, 0x83, 0xff, 0xe1, 0xff, 0xc0, 0x3f, 
  0x00, 0x01, 0xff, 0xcf, 0xef, 0xe1, 0xff, 0xff, 0x1f, 0xff, 0x87, 0xef, 0xc1, 0xff, 0x00, 0x3f, 
  0x00, 0x01, 0xff, 0xdf, 0xdf, 0xc7, 0xef, 0xfe, 0x3f, 0xff, 0x1f, 0xbf, 0xc3, 0xfe, 0x00, 0x3f, 
  0x00, 0x03, 0xef, 0xff, 0xff, 0x87, 0xdf, 0xfe, 0xff, 0xfe, 0x3f, 0xff, 0xc7, 0xfc, 0x00, 0xfe, 
  0x00, 0x0f, 0xcf, 0xff, 0xff, 0x0f, 0xdf, 0x7f, 0xfd, 0xfe, 0x3f, 0xff, 0xc7, 0xf8, 0x03, 0xfe, 
  0x00, 0x1f, 0x8f, 0xff, 0xfe, 0x1f, 0xbe, 0xff, 0xf9, 0xfc, 0xff, 0xff, 0x8f, 0xf0, 0x0f, 0xfc, 
  0x00, 0x1f, 0x07, 0xf8, 0xfc, 0x3e, 0xfe, 0xff, 0xf3, 0xf9, 0xf8, 0x1f, 0x8f, 0xf0, 0xff, 0xf8, 
  0x00, 0x3e, 0x07, 0xfc, 0xfc, 0x7f, 0xfc, 0xff, 0xc7, 0xf3, 0xf0, 0x3f, 0x9f, 0xef, 0xff, 0xe0, 
  0x00, 0xfe, 0x0f, 0xfc, 0xfc, 0xff, 0xf8, 0xff, 0x83, 0xf7, 0xe0, 0x3f, 0x3f, 0xff, 0xff, 0x80, 
  0x01, 0xfc, 0x0f, 0xf9, 0xfb, 0xff, 0xf0, 0xff, 0x07, 0xef, 0x80, 0x7f, 0x3f, 0xff, 0xfe, 0x00, 
  0x03, 0xf0, 0x0f, 0xf1, 0xff, 0xf7, 0xe1, 0xf8, 0x07, 0xcf, 0x00, 0x7e, 0x7f, 0xff, 0x80, 0x00, 
  0x03, 0xf0, 0x0f, 0xe1, 0xff, 0xef, 0xc1, 0xe0, 0x0f, 0xff, 0x00, 0x7b, 0xff, 0xfe, 0x00, 0x00, 
  0x07, 0xc0, 0x0f, 0xe0, 0xff, 0xbf, 0x80, 0xc0, 0x0f, 0xbe, 0x00, 0xf3, 0xff, 0x80, 0x00, 0x00, 
  0x0f, 0x80, 0x0f, 0xc0, 0x78, 0x7f, 0x80, 0x00, 0x1f, 0x18, 0x00, 0x03, 0xf0, 0x00, 0x00, 0x00, 
  0x1f, 0x00, 0x0f, 0x80, 0x00, 0xff, 0xff, 0x83, 0xff, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x7c, 
  0x3f, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 
  0x7e, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 
  0xfc, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 
  0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 
  0x70, 0xf7, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// Sega Logo Bitmap (128x32 Pixel) - Vollbild
#define SEGA_LOGO_HEIGHT 32
#define SEGA_LOGO_WIDTH 128

#define SEGA_LOGO_HEIGHT 32
#define SEGA_LOGO_WIDTH 128

#define SEGA_LOGO_INVERT_HEIGHT 32
#define SEGA_LOGO_INVERT_WIDTH 128

// array size is 512
static const byte sega_logo[] PROGMEM  = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x03, 0xff, 0xfc, 0x01, 0xff, 0xff, 0x80, 0x3f, 0xff, 0xfc, 0x00, 0x03, 0xf0, 0x00, 0x00, 
  0x00, 0x3f, 0xff, 0xfc, 0x0f, 0xff, 0xff, 0x81, 0xff, 0xff, 0xfe, 0x00, 0x0f, 0xfc, 0x00, 0x00, 
  0x00, 0xff, 0xff, 0xfc, 0x3f, 0xff, 0xff, 0x87, 0xff, 0xff, 0xfe, 0x00, 0x1f, 0xfe, 0x00, 0x00, 
  0x01, 0xff, 0xff, 0xfc, 0x7f, 0xff, 0xff, 0x0f, 0xff, 0xff, 0xfc, 0x00, 0x1f, 0xff, 0x00, 0x00, 
  0x03, 0xf8, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x1f, 0xc0, 0x00, 0x00, 0x00, 0x3e, 0x1f, 0x00, 0x00, 
  0x03, 0xf7, 0xff, 0xfc, 0xfc, 0xff, 0xff, 0x9f, 0x9f, 0xff, 0xfe, 0x00, 0x3e, 0xef, 0x80, 0x00, 
  0x07, 0xef, 0xff, 0xfd, 0xf9, 0xff, 0xff, 0xbf, 0x7f, 0xff, 0xfe, 0x00, 0x7f, 0xef, 0x80, 0x00, 
  0x07, 0xef, 0xff, 0xfd, 0xfb, 0xff, 0xff, 0xbe, 0x7f, 0xff, 0xfe, 0x00, 0x7d, 0xf7, 0xc0, 0x00, 
  0x07, 0xcf, 0x80, 0x01, 0xf3, 0xe0, 0x00, 0x3e, 0x7c, 0x00, 0x00, 0x00, 0xfd, 0xf7, 0xe0, 0x00, 
  0x07, 0xef, 0xf0, 0x01, 0xfb, 0xff, 0xfc, 0x3e, 0x7d, 0xff, 0xfc, 0x00, 0xfb, 0xfb, 0xe0, 0x00, 
  0x07, 0xef, 0xff, 0x81, 0xfb, 0xff, 0xfc, 0x3e, 0x7f, 0xff, 0xfe, 0x01, 0xf7, 0xfb, 0xf0, 0x00, 
  0x03, 0xf7, 0xff, 0xc1, 0xfb, 0xff, 0xfc, 0x3e, 0x7f, 0xff, 0xfe, 0x01, 0xf7, 0xfd, 0xf0, 0x00, 
  0x03, 0xf8, 0xff, 0xf1, 0xf1, 0xc7, 0x18, 0x3e, 0x7c, 0x38, 0x7e, 0x03, 0xef, 0xfd, 0xf8, 0x00, 
  0x01, 0xff, 0x87, 0xf9, 0xf9, 0xff, 0xf8, 0x3e, 0x7d, 0xff, 0x3e, 0x07, 0xef, 0xbe, 0xf8, 0x00, 
  0x00, 0xff, 0xf8, 0xf9, 0xfb, 0xff, 0xfc, 0x3e, 0x7f, 0xff, 0xbe, 0x07, 0xdf, 0x3e, 0xfc, 0x00, 
  0x00, 0x3f, 0xfe, 0xfd, 0xfb, 0xff, 0xfc, 0x3e, 0x7f, 0xff, 0xbe, 0x0f, 0xdf, 0x1f, 0x7c, 0x00, 
  0x00, 0x03, 0xff, 0x7d, 0xf3, 0xff, 0xfc, 0x3e, 0x7f, 0xff, 0xbe, 0x0f, 0xbe, 0x1f, 0xbe, 0x00, 
  0x00, 0x00, 0x7f, 0x7d, 0xfb, 0xe0, 0x00, 0x3e, 0x7c, 0x1f, 0xbe, 0x1f, 0xbe, 0x0f, 0xbe, 0x00, 
  0x07, 0xff, 0xff, 0x7d, 0xfb, 0xff, 0xff, 0xbe, 0x7f, 0xff, 0xbe, 0x1f, 0x7e, 0x0f, 0xdf, 0x00, 
  0x0f, 0xff, 0xfe, 0xfd, 0xf9, 0xff, 0xff, 0xbf, 0x7f, 0xff, 0xbe, 0x3f, 0x7f, 0xff, 0xdf, 0x00, 
  0x0f, 0xff, 0xfc, 0xf8, 0xfc, 0xff, 0xff, 0x9f, 0xbf, 0xff, 0xbe, 0x3e, 0xff, 0xff, 0xef, 0x80, 
  0x07, 0xff, 0xe3, 0xf8, 0xfe, 0x1f, 0xff, 0x1f, 0xc7, 0xff, 0x3e, 0x7e, 0xff, 0xff, 0xef, 0x80, 
  0x07, 0xff, 0xff, 0xf0, 0x7f, 0xff, 0xff, 0x8f, 0xff, 0xff, 0xfe, 0x7d, 0xf0, 0x00, 0x07, 0xc0, 
  0x0f, 0xff, 0xff, 0xc0, 0x1f, 0xff, 0xff, 0x87, 0xff, 0xff, 0xfe, 0xf9, 0xe7, 0xff, 0xff, 0xc0, 
  0x0f, 0xff, 0xff, 0x80, 0x0f, 0xff, 0xff, 0x81, 0xff, 0xff, 0xff, 0xfb, 0xe7, 0xff, 0xff, 0xe0, 
  0x07, 0xff, 0xfc, 0x00, 0x01, 0xff, 0xff, 0x80, 0x7f, 0xff, 0xff, 0xf3, 0xc7, 0xff, 0xff, 0xe0, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// Pin-Definitionen
#define BUTTON_PIN      2   // Taster (mit internem Pull-up)
#define JP1_PIN         3   // Nomad Jumper JP1 (JAP/English Region)
#define JP3_PIN         4   // Nomad Jumper JP3 (50Hz/60Hz Video Format)
#define VF_PIN          6   // Video Format (50/60Hz) - zusätzlich falls vorhanden
#define RST_PIN         7   // Reset Output

// EEPROM Adressen
#define EEPROM_COUNTRY  0   // Aktuelle Region
#define EEPROM_VF       1   // 50/60Hz Setting

// Konstanten
#define COUNTRY_COUNT   3
#define COUNTRY_EU      0
#define COUNTRY_USA     1
#define COUNTRY_JAP     2

// Region Namen
const char* countryNames[COUNTRY_COUNT] = {
    "EU",
    "USA", 
    "JAP"
};

// Nomad Jumper Konfigurationen
// JP1: 0 = English (EU/USA), 1 = Japanese
// JP3: 0 = 60Hz, 1 = 50Hz (wird über VF-Pin gesteuert)
const uint8_t countryJP1[COUNTRY_COUNT] = {
    0,      // EU:  English Mode (JP1 = 0)
    0,      // USA: English Mode (JP1 = 0)  
    1       // JAP: Japanese Mode (JP1 = 1)
};

// Video Format Konfigurationen für JP3
const uint8_t countryVF[COUNTRY_COUNT] = {
    0,      // EU:  50Hz
    1,      // USA: 60Hz
    1       // JAP: 60Hz
};

// Globale Variablen
uint8_t currentCountry = 0;
uint8_t currentVF = 0;
unsigned long lastButtonPress = 0;
bool displayingRegion = false;
unsigned long regionDisplayStart = 0;
bool showingSega = false;
unsigned long lastLogoSwitch = 0;
unsigned long bootAnimationStart = 0;
bool bootAnimationDone = false;

// Funktionsdeklarationen
void loadSettings();
void saveSettings();
void setCountryJumpers();
void setVideoFormat();
void performReset();
void handleButtonPress();
void changeRegion();
void toggleVideoFormat();
void showRegionSelection();
void showVideoFormatChange();
void showNomadLogo();
void showSegaLogo();
void bootAnimation();
void checkLogoSwitch();

void setup() {
    Serial.begin(115200);
    Serial.println(F("Sega Nomad Switchless Mod - Starting..."));
    
    // Pin-Konfiguration
    pinMode(BUTTON_PIN, INPUT_PULLUP);
    pinMode(JP1_PIN, OUTPUT);
    pinMode(JP3_PIN, OUTPUT);
    pinMode(VF_PIN, OUTPUT);
    pinMode(RST_PIN, OUTPUT);
    
    // Reset Pin initial auf HIGH (Open-Drain Simulation)
    digitalWrite(RST_PIN, HIGH);
    
    // OLED Display initialisieren
    if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
        Serial.println(F("OLED Display nicht gefunden!"));
        while(1); // Hängen bleiben
    }
    
    display.clearDisplay();
    display.setTextSize(1);
    display.setTextColor(SSD1306_WHITE);
    display.setCursor(0, 0);
    display.println(F("Nomad Switchless"));
    display.println(F("Initialisiere..."));
    display.display();
    
    // Einstellungen aus EEPROM laden
    loadSettings();
    
    // Aktuelle Einstellungen anwenden
    setCountryJumpers();
    setVideoFormat();
    
    Serial.print(F("Geladene Region: "));
    Serial.println(countryNames[currentCountry]);
    Serial.print(F("Video Format: "));
    Serial.println(currentVF ? F("60Hz") : F("50Hz"));
    
    // Boot Animation starten
    bootAnimationStart = millis();
    bootAnimation();
}

void loop() {
    // Boot Animation prüfen
    if (!bootAnimationDone) {
        unsigned long elapsed = millis() - bootAnimationStart;
        if (elapsed < 3000) {
            // Animation läuft noch
            return;
        } else if (elapsed < 6000) {
            // Sega Logo für 3 Sekunden
            if (!showingSega) {
                showingSega = true;
                showSegaLogo();
            }
            return;
        } else {
            // Boot Animation beendet, zu Nomad Logo wechseln
            bootAnimationDone = true;
            showingSega = false;
            lastLogoSwitch = millis();
            showNomadLogo();
        }
    }
    
    // Button Status prüfen
    if (digitalRead(BUTTON_PIN) == LOW) {
        handleButtonPress();
    }
    
    // Region-Anzeige timeout prüfen
    if (displayingRegion && (millis() - regionDisplayStart > 5000)) {
        displayingRegion = false;
        if (showingSega) {
            showSegaLogo();
        } else {
            showNomadLogo();
        }
    }
    
    // Logo-Wechsel alle 3 Minuten prüfen (nur wenn nicht in Region-Anzeige)
    if (!displayingRegion) {
        checkLogoSwitch();
    }
}

void handleButtonPress() {
    unsigned long pressStart = millis();
    
    // Debouncing
    delay(50);
    if (digitalRead(BUTTON_PIN) == HIGH) return;
    
    // Warten bis Button losgelassen oder Timeout
    while (digitalRead(BUTTON_PIN) == LOW && (millis() - pressStart < 3000)) {
        delay(10);
    }
    
    unsigned long pressDuration = millis() - pressStart;
    
    if (pressDuration < 300) {
        // Kurzer Druck: Reset
        Serial.println(F("Reset ausgelöst"));
        performReset();
    }
    else if (pressDuration < 1500) {
        // Mittlerer Druck: 50/60Hz umschalten
        toggleVideoFormat();
    }
    else {
        // Langer Druck: Region wechseln
        changeRegion();
    }
}

void changeRegion() {
    currentCountry++;
    if (currentCountry >= COUNTRY_COUNT) {
        currentCountry = 0;
    }
    
    setCountryJumpers();
    setVideoFormat(); // Video Format entsprechend der Region setzen
    saveSettings();
    
    Serial.print(F("Region gewechselt zu: "));
    Serial.println(countryNames[currentCountry]);
    
    showRegionSelection();
    performReset();
}

void toggleVideoFormat() {
    currentVF = !currentVF;
    setVideoFormat();
    saveSettings();
    
    Serial.print(F("Video Format gewechselt zu: "));
    Serial.println(currentVF ? F("60Hz") : F("50Hz"));
    
    showVideoFormatChange();
}

void setCountryJumpers() {
    // JP1: 0 = English (EU/USA), 1 = Japanese
    digitalWrite(JP1_PIN, countryJP1[currentCountry] ? HIGH : LOW);
    
    // JP3 wird für Video Format verwendet, aber hauptsächlich über VF_PIN gesteuert
    digitalWrite(JP3_PIN, currentVF ? LOW : HIGH); // 50Hz = HIGH, 60Hz = LOW
}

void setVideoFormat() {
    // Video Format basierend auf Region setzen, aber erlauben manuell zu überschreiben
    digitalWrite(VF_PIN, currentVF ? HIGH : LOW);   // VF Pin: 0 = 50Hz, 1 = 60Hz
    digitalWrite(JP3_PIN, currentVF ? LOW : HIGH);  // JP3: umgekehrt zu VF
}

void performReset() {
    Serial.println(F("Reset durchgeführt"));
    
    // Reset-Puls generieren (Low-Aktiv)
    digitalWrite(RST_PIN, LOW);
    delay(200);
    digitalWrite(RST_PIN, HIGH);
}

void loadSettings() {
    // Gültigkeitsprüfung
    uint8_t country = EEPROM.read(EEPROM_COUNTRY);
    if (country < COUNTRY_COUNT) {
        currentCountry = country;
    }
    
    uint8_t vf = EEPROM.read(EEPROM_VF);
    if (vf <= 1) {
        currentVF = vf;
    } else {
        // Fallback: Video Format basierend auf Region
        currentVF = countryVF[currentCountry];
    }
}

void saveSettings() {
    EEPROM.write(EEPROM_COUNTRY, currentCountry);
    EEPROM.write(EEPROM_VF, currentVF);
}

void showRegionSelection() {
    display.clearDisplay();
    display.setTextSize(2);
    display.setTextColor(SSD1306_WHITE);
    
    // Region Name zentriert anzeigen
    int16_t x = (SCREEN_WIDTH - strlen(countryNames[currentCountry]) * 12) / 2;
    display.setCursor(x, 4);
    display.println(countryNames[currentCountry]);
    
    display.setTextSize(1);
    // Hz-Anzeige zentriert darunter
    String hzText = String(currentVF ? "60Hz" : "50Hz");
    int16_t hzX = (SCREEN_WIDTH - hzText.length() * 6) / 2;
    display.setCursor(hzX, 20);
    display.print(hzText);
    
    display.display();
    
    displayingRegion = true;
    regionDisplayStart = millis();
}

void showVideoFormatChange() {
    display.clearDisplay();
    display.setTextSize(1);
    display.setTextColor(SSD1306_WHITE);
    
    // "Video Format:" zentriert oben
    String formatLabel = "Video Format:";
    int16_t labelX = (SCREEN_WIDTH - formatLabel.length() * 6) / 2;
    display.setCursor(labelX, 6);
    display.println(formatLabel);
    
    // Hz-Wert groß zentriert
    display.setTextSize(2);
    String hzText = String(currentVF ? "60Hz" : "50Hz");
    int16_t hzX = (SCREEN_WIDTH - hzText.length() * 12) / 2;
    display.setCursor(hzX, 16);
    display.println(hzText);
    
    display.display();
    
    displayingRegion = true;  // Gleiche Timeout-Logik verwenden
    regionDisplayStart = millis();
}

void showNomadLogo() {
    display.clearDisplay();
    
    // Sega Nomad Logo fullscreen anzeigen (ohne Status-Text)
    display.drawBitmap(0, 0, nomad, NOMAD_WIDTH, NOMAD_HEIGHT, SSD1306_WHITE);
    
    display.display();
}

void showSegaLogo() {
    display.clearDisplay();
    display.drawBitmap(0, 0, sega_logo, SEGA_LOGO_WIDTH, SEGA_LOGO_HEIGHT, SSD1306_WHITE);
    display.display();
}

void bootAnimation() {
    const char* bootTexts[] = {
        "SEGA NOMAD",
        "SWITCHLESS MOD",
        "v1.0 Arduino",
        "Initializing...",
        "Loading Regions:",
        "[ EU ]  [ USA ]",
        "[ JAP ]",
        "Video Formats:",
        "50Hz / 60Hz",
        "Hardware Check:",
        "JP1......... OK",
        "JP3......... OK",
        "VF.......... OK", 
        "Reset....... OK",
        "OLED........ OK",
        "System Ready!",
        "Welcome to",
        "SEGA NOMAD!"
    };
    
    int numTexts = sizeof(bootTexts) / sizeof(bootTexts[0]);
    unsigned long animDuration = 3000; // 3 Sekunden für Animation
    unsigned long textDelay = animDuration / numTexts;
    
    for (int i = 0; i < numTexts; i++) {
        display.clearDisplay();
        display.setTextSize(1);
        display.setTextColor(SSD1306_WHITE);
        
        // Text zentriert anzeigen
        int16_t x1, y1;
        uint16_t w, h;
        display.getTextBounds(bootTexts[i], 0, 0, &x1, &y1, &w, &h);
        int16_t x = (SCREEN_WIDTH - w) / 2;
        int16_t y = (SCREEN_HEIGHT - h) / 2;
        
        display.setCursor(x, y);
        display.println(bootTexts[i]);
        
        // Progress Bar am unteren Rand
        int progress = ((i + 1) * SCREEN_WIDTH) / numTexts;
        display.drawLine(0, SCREEN_HEIGHT - 2, progress, SCREEN_HEIGHT - 2, SSD1306_WHITE);
        
        display.display();
        delay(textDelay);
    }
    
    // Finale Explosion-Effect
    for (int radius = 1; radius < 20; radius += 2) {
        display.clearDisplay();
        display.drawCircle(SCREEN_WIDTH/2, SCREEN_HEIGHT/2, radius, SSD1306_WHITE);
        display.display();
        delay(30);
    }
}

void checkLogoSwitch() {
    unsigned long currentTime = millis();
    
    if (showingSega) {
        // Sega Logo wird 3 Sekunden angezeigt
        if (currentTime - lastLogoSwitch >= 3000) {
            showingSega = false;
            lastLogoSwitch = currentTime;
            showNomadLogo();
        }
    } else {
        // Nomad Logo wird 3 Minuten angezeigt (180000ms)
        if (currentTime - lastLogoSwitch >= 180000) {
            showingSega = true;
            lastLogoSwitch = currentTime;
            showSegaLogo();
        }
    }
}

/*
 * ANWEISUNGEN FÜR LOGO-INTEGRATION:
 * 
 * ✅ ERLEDIGT: Das Sega Nomad Logo wurde erfolgreich integriert!
 * 
 * Das Logo wird jetzt in der showNomadLogo() Funktion angezeigt:
 * - 128x31 Pixel Bitmap
 * - Status-Text (Region + Hz) in der letzten Zeile
 * - Automatische Anzeige beim Start und nach Timeouts
 */